---
title: Arrays as parameters
sidebar:
  label: " - Array Parameters"
---

As with other variables, you can have array parameters to allow arrays to be passed to functions and procedures. The only real difference is that the array can potentially store significantly more data than other variables. When the array is passed by value, each of its elements must be copied into the parameter. Passing the parameter in this way means that there will be two copies of the data in memory, which takes more time and more memory.

You should avoid passing arrays by value, and instead pass them by reference. When passed by reference, we can think of the array itself being passed across. This gives the called function or procedure access to the data, but does not require that the values be copied across. As we saw before, you can use a `const` reference if you do not want the array's data to be changed.

<a id="FigureArrayPassByRef"></a>
![Arrays should always be passed by reference](./images/array-parameter-idea.png)
<div class="caption"><span class="caption-figure-nbr">Figure x.y: </span>Arrays should always be passed by reference</div><br/>

:::note

- Pass by Reference and Pass by Value are **terms** that explain how data is passed to a Parameter.
- With arrays you should always use *Pass by Reference*. This will be faster and take less memory.
- The **const** keyword can be used to indicate that the parameter should not be able to be changed by the called code.
:::

## In C/C++

Ok, this is one of the places where C/C++ does something *"interesting"*. Because passing an array by value is a bad idea, the language does not allow you to pass arrays by value at all. Instead, when you pass an array to a parameter it will pass the address of the array. This then introduces some inconsistencies in the syntax and the way it treats arrays.

:::tip[Syntax]
:::

- You can use the `[ ]` syntax you do not specify the size of the array. This allows arrays of varying size to be passed into the Function or Procedure. The \texttt{size} parameter is then used by \emph{convention} to carry across the size of the array.

- You do **not** need to get the address of arrays, as you would do with other types when passing to a pointer.



```cpp
/* Program: test-array-passing.c */

void test_pass_in_only_v1(const int data[], int size)
{
    printf("Can only read from data -> %d...%d\n", data[0], data[size - 1]);
}

void test_pass_in_and_out_v1(int data[], int size)
{
    printf("Can read and change data\n");
    data[0] = data[0] + 1;                  //increment first
    data[size - 1] = data[size - 1] * 2;    //double last
}

//----------------------------------------------------------------

void test_pass_in_only_v2(const int *data, int size)
{
    printf("Can only read from data -> %d...%d\n", data[0], data[size - 1]);
}

void test_pass_in_and_out_v2(int *data, int size)
{
    printf("Can read and change data\n");
    data[0] = data[0] + 1;                  //increment first
    data[size - 1] = data[size - 1] * 2;    //double last
}

//----------------------------------------------------------------

void say_hello_to(const char *name)
{
    printf("Hello %s!\n", name);
}

//----------------------------------------------------------------


int main()
{
    int my_data[] = {1, 2, 3};
    int other_data[] = {1, 2};
    
    say_hello_to("Fred");
    
    test_pass_in_and_out_v1(my_data, 3);
    test_pass_in_and_out_v2(other_data, 2);
    
    test_pass_in_only_v1(my_data, 3);
    test_pass_in_only_v1(other_data, 2);
    
    return 0;
}
```


:::tip[Syntax]

In C you cannot pass an array by value, instead all arrays are passed by reference automatically by the language.
 
:::