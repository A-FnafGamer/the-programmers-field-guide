---
title: Designing in General
sidebar:
  label: " - Designing in General"
---

### Designing data in general

When you are designing a program you need to think about each function or procedure, and determine if it requires data to be given to it to enable it to perform its action. Any data it requires must then be
passed to it using Parameters. The key to understanding parameters is to remember that each function/procedure is its own isolated domain. It can have its own data, using local variables, and has its own instructions. In most cases these instructions will need to be given some starting data, some information upon which to act.

One strategy you can use to picture this is to put yourself in the place of the function, or procedure. For example, what would you need to be told in order to determine the number of coins to give in change for a
single coin type. You can not work out the answer without being told the value of the change to be given, and the value of the coin. With these two pieces of information you now have enough to calculate the required output. For example, how many \$2 coins should be given for \$6.50 in change. These two pieces of data can be used to calculate the answer 3. This is exactly what is being coded in the `Coins to Give` function.

In this respect Procedures are the same. In order to give change, the `Give Change` procedure needs some information. It can not act without this information. If you needed to *give change*, you need to be told
something about the amount of change you are giving and the value of the coin you are issuing. In this case, `Give Change` needs to be told the `change value`, the `coin value`, and the description of that coin. With
these details the procedure can then code the steps needed to produce its desired side effects.

Parameters are mostly used to pass a value into a function or procedure. However, in some cases it is useful to pass in the *variable* rather than the *value*. This is the case when you want the function or procedure to *change* the value in the variable passed to it. Take the `change value` parameter in `Give Change` as an example. When this procedure issues some coins, the amount of change still to be given must be updated. For example, when you issue '3 x \$2' for the \$6.50 in change, the new change value will be 50c ($650 - (3 x 200)$). By passing the *variable* into `Give Change` it is possible for this code to change the value in the callers variable, ensuring that the correct change is given.

### Modelling and Abstraction

One of the main keys to understanding programs, and to creating good designs, is to see how each artefact you create models something from the problem. The procedures that you create model the processes, performing actions that relate to the task at hand. The functions model calculations that need to be performed, such as determining how many coins should be given. In the same way the variables that you create will store values related to the problem. Each variable **represents** something, some information related to your program. The *thing* it represents should be reflected in the name given to the variable.

The act of trying to model the problem in software is called **abstraction**. It is the process of determining the features of the problem that are essential to the solution, and capturing these in a way that models reality but keeps only the details we care about. The ability to create your own model is a skill that you learn with experience, taking a lot of practice to really master.

:::note
- A good design will closely model the program's domain. You should be able to relate the artefacts you are creating with things related to the program.
:::