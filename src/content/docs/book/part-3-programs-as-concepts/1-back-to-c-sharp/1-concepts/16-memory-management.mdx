---
title: Memory Management
---

See some different strategies for helping ensure that values on the heap are deleted when they are no longer needed.

Once you allocate a value on the heap, you are responsible for ensuring that the value is deleted when you are finished with it. Keeping track of this can be very challenging, as the relationships between objects is likely to change as the program runs. In general, there are three main ways for managing memory.

At the lowest level, there are languages that require you to **manually manage memory**. These languages offer basic methods that you can call to allocate and then delete memory from the heap. You need to then work out your own strategy for ensuring that you delete objects at appropriate times. To do this effectively you need to establish ideas of ownership, so that you know when an object should be deleted. This puts the burden of memory management in the hands of the developers.

Another option is known as **reference counting**. In these languages, the objects themselves keep track of who knows them, and can delete themselves when they are no longer being used. This requires that developers adhere to certain conventions, so that objects know when they are referenced and when they are no longer referenced. Depending on the language, the compiler may be able to add any reference counting code automatically, but it still does require some level of understanding on the developers part.

Lastly, there is **garbage collection**. Languages which use this approach, including C#, have a separate task that runs alongside your code keeping track of your objects. The garbage collector runs periodically, and traces through the links between objects to identify and delete those objects that are no longer being referenced.

Each of these approaches has its own advantages and disadvantages, and are used in different commercial programming langages. Languages like C and C++ use manual memory management, Objective-C and Swift use automatic reference counting, while Java and C# use garbage collection.


### Your  Task

Think about these different approaches. What do you think some of the trade offs are for having the language or environment take care of these things for you?