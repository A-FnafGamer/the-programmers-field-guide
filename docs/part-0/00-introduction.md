---
sidebar_position: 1
description: Plan your journey to harness the power of computing.
---

# 0. Introduction

## Welcome to the Programmer's Field Guide

Where ever you look, computers and software are driving the world. The ability to understand and shape how these computers operate will ensure that you can make the most of these tools, and connect with the growing field of computing.

The Programmer's Field Guide will take you on a journey, guiding you to develop the skills you need to understand and build software and engage with the growing capabilities that computing offers. Through your journey, you will explore computing, how computers work, and the code to make them work for you. You will acquire new acquire tools for your toolbelt, with an understanding of what these tools do, when to use them, and how they work. The knowledge, skills, and attitudes you develop through this journey will set you up with the capability to engage in the computing profession and keep learning programming languages, libraries, and tools as you and the field grow and change over time.

This first chapter will explain the path ahead. It will give you an overview of the parts in the book, and the chapters in this first part - [Part 0](../category/part-0-getting-started).

By the end of this chapter you will be able to:

- Describe the main parts of the field guide and the emphasis of each part.
- Gather the resources you need to get started learning to program.

## The Journey Ahead

This book focuses on helping you develop a strong mental model of programming. It takes a bottom-up approach to introducing tools and capabilities, ensuring you can understand how these build upon each other as you go. Initially, you will explore how instructions in the computer work at the lower levels, to help you understand what is happening as your programs run. This will ensure you can see how the different parts all start to work together, meaning you can explain how your programs work which in turn will help you know how to get new things working in the future. If you want to explore lower levels, have a look at books on computer systems. These often explore the lower-level aspects of how computers work, the gates and how these can be combined to build a computer. The [From Nand to Tetris](https://www.nand2tetris.org) book is a great example of this.

We are currently in **Part 0**, which sets the background for the book. In this part, the introduction outlines the approach of the book, with the following chapters on the [Digital Realities](abstraction), [Computer Use](computer-use) and [Building Programs](building-programs) helping you start to work with the computer through command line instructions and low-level tools.

**Part 1** of the book will focus on *programs as instructions*. This part will help you understand how the most basic of the elements work within these digital realities. You will see how each of these works looking at them in detail to see how they work at the lower levels of abstraction. Understanding how these work will help you see how these core parts work within the programs we create. Programs in this section will be relatively small, enabling you to focus on the mechanics and effect of each instruction. Your learning from this will give you a solid foundation upon which to start building larger programs.

**Part 2** moves up to consider how we can start building larger *things* within our programs - taking it to another level of abstraction. This will introduce you to tools to combine things, helping package instructions and data into the kinds of entities that exist within even the most sophisticated programs. Programs in this section will start to get a little larger, as you build more meaningful entities. However, we will focus mostly on how the *programs are* a way of *organising* code. What you learn from this will help set you up to start thinking about how these come together.

In **Part 3**, we will move away from code to think more about software design. You will see how you can use the different kinds of packages (from part 2) to build complex realities, with *programs as conceptual models*. Building upon your understanding of how to organise code, and your understanding of how programs work as instructions. With this understanding, you will have the knowledge and skills needed to design and create sophisticated programs.

We conclude the book in **Part 4** where we look at how to use the things you have learnt to build a range of real-world software systems. This will give you an initial look at how to use the things you have learnt, with professional tools, to create any kind of software system.

## What tools do I need?

This book is designed to work on a range of computers but has a focus on using the [Raspberry Pi](https://www.raspberrypi.org) single-board computer. 

Programmers Multi-Tool

## What language will I learn?

There is often a fixation on which language you will use when learning to program. Should we pick this language or another, what should inform the choice of language?

This book will focus on building your mental model. The focus is not on a particular language, but on things common across most languages. It will use language features common to many programming languages, helping you build a strong mental model that will be capable of quickly picking up and using many different programming languages. Each chapter will also contain a section that reaches out to other languages, showing you how the concepts covered exist or ar different in other languages. This will help you see that what you are learning is *more* than just *a programming language*.

_So which _language_ will I_ use?*

The book starts with C#, transitions to C/C++, then comes back to C#. This will allow you to focus on a common style of programming syntax, the C-style syntax while giving you a modern language to work with. More importantly, these languages provide mechanisms to demonstrate the breadth of capabilities you need to explore.

While the guide uses these languages to demonstrate programming concepts, it will not explore the language in depth. It will not focus on, or examine, things that are not common elsewhere. This means that you will need to further study these languages after finishing this book to say you have *leanrt* them in detail. But the great thing is, you will have all of the skills and understanding you need to learn this with the resources available online and through things like generative artificial intelligence.

Most modern systems are built using multiple programming languages - as different languages are better at different things. There is no one best language, so our approach aims to show you the common features across languages and give you set you up to quickly pick up the language that best fits your needs. This is something we draw upon in Part 4, where we will use different programming languages as we build out these different real-world programs.


