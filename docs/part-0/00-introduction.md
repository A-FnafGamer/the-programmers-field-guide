---
sidebar_position: 1
description: Plan your journey to harness the power of computing.
---

# 0. Introduction

## Welcome to the Programmer's Field Guide

Where ever you look, computers and software are driving the world. The ability to understand and shape how these computers operate will ensure that you can make the most of these tools, and connect with the growing field of computing.

The Programmer's Field Guide will take you on a journey, guiding you to develop the skills you need to understand and build software and engage with the growing capabilities that computing offers. Through your journey, you will explore computing, how computers work, and the code to make them work for you. You will acquire new acquire tools for your toolbelt, with an understanding of what these tools do, when to use them, and how they work. The knowledge, skills, and attitudes you develop through this journey will set you up with the capability to engage in the computing profession and keep learning programming languages, libraries, and tools as you and the field grow and change over time.

This first chapter will explain the path ahead. It will give you an overview of the parts in the book, and the chapters in this first part - [Part 0](../category/part-0-getting-started).

By the end of this chapter you will be able to:

- Describe the main parts of the field guide and the emphasis of each part.
- Gather the resources you need to get started learning to program.

## The Journey Ahead

This book focuses on helping you develop a strong mental model of programming. It takes a bottom-up approach to introducing tools and capabilities, ensuring you can understand how these build upon each other as you go. Initially, you will explore how instructions in the computer work at the lower levels, to help you understand what is happening as your programs run. This will ensure you can see how the different parts all start to work together, meaning you can explain how your programs work which in turn will help you know how to get new things working in the future. If you want to explore lower levels, have a look at books on computer systems. These often explore the lower-level aspects of how computers work, the gates and how these can be combined to build a computer. The [From Nand to Tetris](https://www.nand2tetris.org) book is a great example of this.

We are currently in **Part 0**, which sets the background for the book. In this part, the introduction outlines the approach of the book, with the following chapters on the [Digital Realities](abstraction), [Computer Use](computer-use) and [Building Programs](building-programs) helping you start to work with the computer through command line instructions and low-level tools.

**Part 1** of the book will focus on *programs as instructions*. This part will help you understand how the most basic of the elements work within these digital realities. You will see how each of these works looking at them in detail to see how they work at the lower levels of abstraction. Understanding how these work will help you see how these core parts work within the programs we create. Programs in this section will be relatively small, enabling you to focus on the mechanics and effect of each instruction. Your learning from this will give you a solid foundation upon which to start building larger programs.

**Part 2** moves up to consider how we can start building larger *things* within our programs - taking it to another level of abstraction. This will introduce you to tools to combine things, helping package instructions and data into the kinds of entities that exist within even the most sophisticated programs. Programs in this section will start to get a little larger, as you build more meaningful entities. However, we will focus mostly on how the *programs are* a way of *organising* code. What you learn from this will help set you up to start thinking about how these come together.

In **Part 3**, we will move away from code to think more about software design. You will see how you can use the different kinds of packages (from part 2) to build complex realities, with *programs as conceptual models*. Building upon your understanding of how to organise code, and your understanding of how programs work as instructions. With this understanding, you will have the knowledge and skills needed to design and create sophisticated programs.

We conclude the book in **Part 4** where we look at how to use the things you have learnt to build a range of real-world software systems. This will give you an initial look at how to use the things you have learnt, with professional tools, to create any kind of software system.

## What tools do I need?

Programming is a practical skill that will require time and effort to master. In order to practice, you will need access to a computer and a set of programming tools. The tasks and activities in the Programmer’s Field Guide are designed to work on a range of computers, and will use free and open source tools.

While you could use any computer, the field guide targets the [Raspberry Pi](https://www.raspberrypi.org) single-board computer. If you can get yourself a Raspberry Pi, then you will be set for the journey. For the adventurous, we recommend the **Programmers Multi-Tool** - a custom designed hardware setup. This can be your physical companion on your quest to acquire mastery of the field.

:::note

The **Programmers Multi-Tool** is a Raspberry Pi based project, with everything you need to build your own small computer. If you have access to a Makerspace, you can purchase the parts and put this together in no time.

:::

[Chapter 2](computer-use) has the instructions on getting your Raspberry Pi or computer setup, and will get you started using command line tools.

## What language will I learn?

There is often a fixation on which language you will use when learning to program. Should we pick this language or another, what should inform the choice of language?

This book will focus on building your mental model - helping you learn how to program with skills that work across many programming languages. The focus is not on a particular language, but on things common across languages. Examples and activities will focus on a single language, giving you the chance to practice what you are learning and helping you build a strong mental model. 

While there is a single language as our basis, each chapter will also contain a section that reaches out to other languages, showing you how the concepts covered exist or are different in other languages. This will help you see that what you are learning is *more* than just *a programming language*. By the end of your journey, you will be capable of quickly picking up and using many different programming languages. 

_So which _language_ will I_ use?*

The book starts with C# for Part 1, transitions to C/C++ for the start of Part 2, then return to C#. This will ensure you are using an appropriate language for each concept. Neither C# nor C/C++ is suitable for all tasks. Some things don’t really exist in C#, or add necessary challenges in C/C++. Mising the two will allow us an easier path, while still giving access to a complete experience. The good thing is, both languages have a common syntax. Both languages use the C-style syntax, meaning the transition shouldn’t be too challenging.

While the guide uses these languages to demonstrate programming concepts, it will not explore the language in depth. It will not focus on, or examine, things that are not common elsewhere. This means that you will need to further study these languages after finishing this book to say you have *leanrt* them in detail. But the great thing is you will have all of the skills and understanding you need to learn this with the resources available online and through things like generative artificial intelligence.

Most modern systems are built using multiple programming languages - as different languages are better at different things. There is no one best language, so our approach aims to show you the common features across languages and give you set you up to quickly pick up the language that best fits your needs. This is something we draw upon in Part 4, where we will use different programming languages as we build out these different real-world programs.

## Overview of Part 0

Part 0 consists of three chapters - [Chapter 1](abstraction) will start your journey by lpoking at what programs are and how to start thinking about them. [Chapter 2](computer-use) will help you acquire the first tools for your toolbelt as you setup your Raspberry Pi or Computer and walking you through the use of the command line. [Chapter 3](building-programs) will wrap up Part 0 by getting you started building your first program on your new setup.

Now that we have this part of the journey mapped out, lets get going.